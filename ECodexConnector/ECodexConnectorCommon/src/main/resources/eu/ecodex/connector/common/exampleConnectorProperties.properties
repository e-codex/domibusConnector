# defines the endpoint address of the gateway webservice.
gateway.endpoint.address=127.0.0.1:8080

# defines the name and role of the gateway. The name is the ISO country code of the sending gateway connected to this connector.
gateway.name=AT
gateway.role=GW

# As every nation has its own backend client, an implementation of the ECodexConnectorNationalBackendClient interface has to be implemented which handles the connection to its own backend.
# Here the full qualified name of the implementation class which implements ECodexConnectorNationalBackendClient must be given.
connector.national.backend.client.implementation.class.name=eu.ecodex.connector.nbc.ECodexConnectorNationalBackendClientImpl

# defines if content mapper module should be used. 
# If there is a certain national format the eCodex message should be transformed to
# this content mapper handles the mapping. The main class ECodexConnectorContentMapperImpl has to be
# extended.
connector.use.content.mapper=true

# If content mapper module is used, an implementation of the ECodexConnectorContentMapper interface has to be implemented with national content.
# Here the full qualified name of the implementation class which implements ECodexConnectorContentMapper must be given.
# If no content mapper is used (connector.use.content.mappe set false), property can be left empty:
# property connector.content.mapper.implementation.class.name=
connector.content.mapper.implementation.class.name=eu.ecodex.connector.mapping.ECodexConnectorContentMapperImpl

# defines if security toolkit should be used. 
# If messages should be encrypted with a trustOkToken and be sent in an encrypted container,
# this module has to be activated. 
connector.use.security.toolkit=true

# Possibility to overwrite the security toolkit implementation class. Mainly for countries without signed documents.
connector.security.toolkit.implementation.class.name=

# defines if evidences toolkit should be used.
# In ebMS standard messages should be confirmed or declined by evidences messages sent back to the message sender.
# Those messages contain the state of the message sent and are therefore good to hold reliability.
connector.use.evidences.toolkit=true

# defines how often the gateway and the national backend system should be checked for messages.
# All messages in both directions should be handled entirely before next period starts. So no conflicts are produced.
# Value is in milliseconds. For seconds divide value with 1000. For example 30 000 milliseconds are 30 seconds.
connector.check.messages.period.ms=30000

# defines the timeout for RelayREMMD evidence to be sent back when an outgoing message was sent. 
# After this period, if an outgoing message was sent to the gateway successfully and no RelayREMMD evidence was received, 
# a RelayREMMDRejection will be created for this evidence an sent back to the national system.
# Value is in milliseconds. For seconds divide value with 1000. For hours divide value with 3600000.
connector.evidence.relayremmd.timeout.ms=30000

connector.evidence.delivery.timeout.ms=30000

connector.evidence.retrieval.timeout.ms=30000

# Following properties define the connection to the database where message states should be logged.
# The dialect and driverClassName values depend on the dbms that is in use. Here some examples:
# Oracle:
# connector.database.dialect=org.hibernate.dialect.Oracle10gDialect
# connector.database.driverClassName=oracle.jdbc.driver.OracleDriver
# MySQL:
# connector.database.dialect=org.hibernate.dialect.MySQL5InnoDBDialect
# connector.database.driverClassName=com.mysql.jdbc.Driver
connector.database.dialect=
connector.database.driverClassName=
connector.database.url=
connector.database.username=
connector.database.password=

# To be able to sign evidences and message contents a keystore with certificate and private key integrated must be used. Here are the
# credentials to set.
java.keystore.path=file:path/keystore.jks
java.keystore.password=
key.alias=
key.password=

# As the security toolkit uses web connections for loading trust stores, proxy settings must be set in case there is one.
http.proxy.enabled=true
http.proxy.host=127.0.0.1
http.proxy.port=8080
http.proxy.user=
http.proxy.password=

# Indicates the algorithm with which the message content hash value should be generated.
hash.algorithm=MD5

# For the security library to build the token it is necessary to provide your ISO country code, who provides the service (the connector and gateway)
# and to tell the lib wether a container should be signed SIGNATURE_BASED (default behaviour) or AUTHENTICATION_BASED. In this case there has to be
# implemented a connector.security.toolkit.implementation.class.name.
token.issuer.country=
token.issuer.service.provider=
token.issuer.aes.value=SIGNATURE_BASED

# For the evidence builder the postal address of the original sender should be set.
postal.address.street=
postal.address.locality=
postal.address.postal.code=
postal.address.country=