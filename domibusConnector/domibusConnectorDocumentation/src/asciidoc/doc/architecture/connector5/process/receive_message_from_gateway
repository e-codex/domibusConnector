
ifndef::basepath[]
:basepath: ../../../../
endif::basepath[]

ifndef::header[]
include::{basepath}/doc/header.adoc[]
endif::header[]

= Receive Message from Gateway

== Process description

This is an abstract process with two extensions.
The used extension depends on the message type received.

During this process the web-service request from the gateway is open.
This is necessary to receive all data required from the web-service during this process.

This process MUST end by responding and closing the web-service request with an acknowledgement.
This acknowledgement can either be positive (success), or negative (fail) with a qualified error message.

== Process diagram

The diagram for this process is extension specific and therefore placed in the extension chapters.

== Common Process-Steps
All process-steps that are common for all extensions are described here.

.Receive Message from Gateway common process-steps
|===
| step | description | parameters | returns | on success | on fail | module responsibility

|Find Domain
|ABSTRACT - defined in extension
|DomibusConnectorMessageType transitionMessage
|DcDomain identifiedDomain
|Map to BusinessModel
|Always ends by returning a DcDomain.
Misconfiguration of the domibusConnector that leads to no DcDomain must be prevented!
|Controller

|Map to BusinessModel
|mapping the transition model to the business model
a|* DomibusConnectorMessageType transitionMessage
* DcDomain identifiedDomain
|DomibusConnectorMessage businessModelMessage
|Persist message
|By successfully processing the validation of the transition message, this process-step must not fail.
|Controller

|Persist message
a|* DC_MESSAGE
* DC_EBMS_ROUTE
* DC_MSG_CONTENT (without storage refs)
* DC_MSG_PROCESS_STEP all steps to this process. Already handled steps with result.

This process-step MUST be transactional! The message data as a whole is either persisted and committed, or the transaction must be rolled back!

|DomibusConnectorMessage businessModelMessage
|DomibusConnectorMessage businessModelMessage
|Write to storage
|ABSTRACT - defined in extension
|Controller

|Write to storage
|Write content: message content files are received from CXF and put on storage.
DC_MSG_CONTENT update with storage references.
DC_MSG_PROCESS_STEP update with result.
|DomibusConnectorMessage businessModelMessage
|DomibusConnectorMessage businessModelMessage
|Put on queue
|ABSTRACT - defined in extension
|Controller

|Put on queue
|The message is put on the queue for business processing.

DC_MSG_PROCESS_STEP update with result.
|DomibusConnectorMessage businessModelMessage
|result
|acknowledge Request
|prepare for retry
|Controller

|prepare for retry
|Message is prepared for retry. â†’ new process!
|DomibusConnectorMessage businessModelMessage
|result
|acknowledge Request
|cleanUp
|Controller

|cleanUp
|Persisted message data and storage contents are deleted.
|DomibusConnectorMessage businessModelMessage
|result
|acknowledge Request
|Exception
|Controller

|acknowledge request
|The gateway request is answered with an ACK.
|result
|
|End Process
|Exception
|Link

|Exception
|A typed exception is thrown back to webservice.
|exception message
|
|End Process
|
|Link

|===

===== Map to BusinessModel

.Map to BusinessModel activity diagram

[plantuml,map_to_BM_activity,format=svg]
----
@startuml

start
:Generate connectorMessageId;
:Map messageDetails by copy properties;
:Map ebms action;
:Map ebms service;
:Map ebms fromParty;
:Map ebms toParty;

if(confirmations attached) then (true)
    while (confirmations available)
        :Map confirmation;
    endwhile
else
endif

if(messageContent attached) then (true)
    :Map messageContent;
    :Build model object with mapped messageDetails and mapped content;
    if(confirmations available?) then (true)
        :add mapped confirmations;
    else
    endif
else
    :extract first confirmation;
    :Build model object with mapped messageDetails and first confirmation;
    if(still confirmations available?) then (true)
        :add mapped confirmations;
    else
    endif
endif

while (attachments attached)
    :Map attachment;
endwhile

:set connectorMessageId to model;

stop




@enduml
----

===== Write to storage

.Write to storage activity diagram

[plantuml,write_to_storage_activity,format=svg]
----
@startuml

start
:Write to storage;

@enduml
----


== Extensions

=== Receive Business Message from Gateway
This extension describes the process steps of receiving a business message from the gateway.

//==== Component diagram
//
//[plantuml,receive_BM_from_gateway_component,format=svg]
//----
//@startuml
//
//top to bottom direction
//skinparam monochrome false
//skinparam linetype ortho
//skinparam componentStyle uml2
//
//[FindDomain]
//[MapToBusinessModel]
//[PersistMessage]
//[WriteToStorage]
//[PutOnQueue]
//[PrepareForRetry]
//[CleanUp]
//[AcknowledgeRequest]
//
//[Create and send RELAY_REMMD_REJECTION]
//
//
//queue toConnectorQueue
//queue retryQueue
//
//database connectorDatabase
//
//node Storage
//
//StartProcess --> FindDomain
//FindDomain --> [MapToBusinessModel] : onSuccess
//FindDomain --> [Create and send RELAY_REMMD_REJECTION] : onFail
//[MapToBusinessModel] --> [PersistMessage] : onSuccess
//[MapToBusinessModel] --> [Create and send RELAY_REMMD_REJECTION] : onFail
//[PersistMessage] --> [WriteToStorage] : onSuccess
//[PersistMessage] ..> connectorDatabase : persistTo
//[PersistMessage] --> [Create and send RELAY_REMMD_REJECTION] : onFail
//[WriteToStorage] ..> Storage : writeTo
//[WriteToStorage] ..> connectorDatabase : update
//[WriteToStorage] --> [PutOnQueue] : onSuccess
//[PutOnQueue] ..> toConnectorQueue
//[PutOnQueue] --> [PrepareForRetry] : onFail
//[PutOnQueue] --> [AcknowledgeRequest] : onSuccess
//[PrepareForRetry] ..> retryQueue
//[PrepareForRetry] --> [AcknowledgeRequest] : onSuccess
//[PrepareForRetry] --> [CleanUp] : onFail
//[CleanUp] --> [AcknowledgeRequest] : onSuccess
//[CleanUp] --> Exception : onFail
//[Create and send RELAY_REMMD_REJECTION] --> [CleanUp]
//
//
//
//@enduml
//----

==== Process diagram

.receive business message from gateway - activity diagram

[plantuml,receive_BM_from_gateway_activity,format=svg]
----
@startuml

start
:FindDomain;
:MapToBM;
:PersistMessage;
        if (message entirely persisted) then (true)
            :WriteToStorage;
            if (all message parts stored) then (true)
                :PutOnQueue;
                if (message put on toConnector queue) then (true)
                    :acknowledgeRequest;
                    stop
                else (false)
                    :prepare for retry;
                    :cleanUp;
                    :acknowledgeRequest;
                    stop
                endif
            else (false)
                :Create and send RELAY_REMMD_REJECTION;
                :cleanUp;
                :acknowledgeRequest;
                stop
            endif
        else (false)
            :Create and send RELAY_REMMD_REJECTION;
            :acknowledgeRequest;
            stop
        endif


@enduml
----


==== Extension specific Process-Steps

Here, only the process-steps are described that extend the common process-steps.



.Receive Business Message from Gateway process-steps
|===
| step | description | parameters | returns | on success | on fail | module responsibility

|Find Domain
a|
* Is there a referenced message?
* Are there messages for this conversation already?
* in case of multi-tenancy: which domain is sent by the gateway?
* default domain.
|inherited
|inherited
|inherited
|Create and send RELAY_REMMD_REJECTION
|inherited

|Map to BusinessModel
|inherited
|inherited
|inherited
|inherited
|Create and send RELAY_REMMD_REJECTION
|inherited

|Persist MSG
|inherited
|inherited
|inherited
|inherited
|Create and send RELAY_REMMD_REJECTION
|inherited

|Write to Storage
|inherited
|inherited
|inherited
|inherited
|Create and send RELAY_REMMD_REJECTION
|inherited

|Create and send RELAY_REMMD_REJECTION
|If possible, create RELAY_REMMD_REJECTION and send it as new WS message to gateway.
This is not treated as connector message!
|DomibusConnectorMessage
|result
|cleanUp
|cleanUp
|Controller
|===

===== Find Domain - Business Message

.Find Domain activity diagram - Business Message

[plantuml,find_domain_activity_BM,format=svg]
----
@startuml

start
:FindDomain;
if (are there multiple active DcDomains?) then (true)
if(is there a referenced message?) then (true)
    :return DcDomain from ref msg;
    stop
else (false)
    if(are there messages within this conversation already?) then (true)
        :return DcDomain from other conversation messages;
        stop
    else(false)
        if(which MT domain is sent by gateway) then (true)
            :return DcDomain that references gateway domain;
            stop
        else (false)
            :return default DcDomain;
            stop
        endif
    endif
endif
else (false)
    :return default DcDomain;
            stop
endif
@enduml
----

===== Create and send RELAY_REMMD_REJECTION

.Create and send RELAY_REMMD_REJECTION activity diagram

[plantuml,create_send_RELAY_REMMD_REJECTION_activity_BM,format=svg]
----
@startuml

start
:Create and send RELAY_REMMD_REJECTION;
if(data to create evidence available?) then (true)
    :create evidence;
    if(evidence created successfully) then (true)
        :build message structure to submit;
        :submit message to gateway;
        if(message submitted) then (true)
            stop
        else (false)
        endif
    else (false)
    endif
else (false)
endif

:throw Exception;
end

@enduml
----

=== Receive Confirmation Message from Gateway

//==== UML diagram
//
//[plantuml,receive_CM_from_gateway,format=svg]
//----
//@startuml
//
//top to bottom direction
//skinparam monochrome false
//skinparam linetype ortho
//skinparam componentStyle uml2
//
//[FindDomain]
//[MapToBusinessModel]
//[PersistMessage]
//[WriteToStorage]
//[PutOnQueue]
//[PrepareForRetry]
//[CleanUp]
//[AcknowledgeRequest]
//
//
//queue toConnectorQueue
//queue retryQueue
//
//database connectorDatabase
//
//node Storage
//
//StartProcess --> FindDomain
//FindDomain --> [MapToBusinessModel] : onSuccess
//[FindDomain] --> [AcknowledgeRequest] : onFail
//[MapToBusinessModel] --> [PersistMessage] : onSuccess
//[MapToBusinessModel] --> [AcknowledgeRequest] : onFail
//[PersistMessage] --> [WriteToStorage] : onSuccess
//[PersistMessage] --> connectorDatabase : persistTo
//[PersistMessage] --> [AcknowledgeRequest] : onFail
//[WriteToStorage] --> Storage : writeTo
//[WriteToStorage] --> connectorDatabase : update
//[WriteToStorage] --> [PutOnQueue] : onSuccess
//[PutOnQueue] --> toConnectorQueue
//[PutOnQueue] --> [PrepareForRetry] : onFail
//[PutOnQueue] --> [AcknowledgeRequest] : onSuccess
//[PrepareForRetry] --> retryQueue
//[PrepareForRetry] --> [AcknowledgeRequest] : onSuccess
//[PrepareForRetry] --> [CleanUp] : onFail
//[CleanUp] --> [AcknowledgeRequest] : onSuccess
//[CleanUp] --> Exception : onFail
//
//
//
//@enduml
//----

==== Process diagram

.receive confirmation message from gateway - activity diagram

[plantuml,receive_CM_from_gateway_activity,format=svg]
----
@startuml

start
:FindDomain;
:MapToBM;
:PersistMessage;
        if (message entirely persisted) then (true)
            :WriteToStorage;
            if (all message parts stored) then (true)
                :PutOnQueue;
                if (message put on toConnector queue) then (true)
                    :acknowledgeRequest;
                    stop
                else (false)
                    :prepare for retry;
                    :cleanUp;
                    :acknowledgeRequest;
                    stop
                endif
            else (false)
                :cleanUp;
                :acknowledgeRequest;
                stop
            endif
        else (false)
            :acknowledgeRequest;
            stop
        endif


@enduml
----



==== Extension specific Process-Steps
Here, only the process-steps are described that extend the common process-steps.

.Receive Confirmation Message from Gateway process-steps
|===
| step | description | parameters | returns | on success | on fail | module responsibility

|Find Domain
|Find original business message by refToMessageId and return domain of it.
|inherited
|inherited
|inherited
|acknowledge Request
|inherited

|Map to BusinessModel
|inherited
|inherited
|inherited
|inherited
|acknowledge Request
|inherited

|Persist MSG
|inherited
|inherited
|inherited
|inherited
|acknowledge Request
|inherited

|Write to Storage
|inherited
|inherited
|inherited
|inherited
|acknowledge Request
|inherited
|===

===== Find Domain - Confirmation Message

.Find Domain activity diagram - Confirmation Message

[plantuml,find_domain_activity_CM,format=svg]
----
@startuml

start
:FindDomain;
if (is there a refToMessageId?) then (true)
    :lookup original business message;

    if(original business message loaded?) then (true)
        :return DcDomain from original business message;
        stop
    else (false)
        :return default DcDomain;
        stop
    endif

else (false)
    :return default DcDomain;
            stop
endif
@enduml
----