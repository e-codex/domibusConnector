
= Data Model Draft

== Persistence Services and their Responsibility

Every service should be responsible for a limited set of tasks. Ideally there are no overlaps in the required data. So every PersistenceService can control their own entity model.

=== ProcessPersistenceService / RawMessagePersistenceService

Responsible for:

* Store Processing / Persist RawMessage
* Retrieve Processing / Load RawMessage
* Retrieve State of processing
* Set State of processing

See also: link:../flows/level0/l0_process_message.adoc#_message_state_diagram[Message State diagram]

//=== MessagePersistenceService
//
//* Load Message
//* Persist Message
//* Append Attachment to Message
//* Append Evidence to Message
//* Set business message state
//* Retrieve business message state
//
//See also: link:../flows/level0/l0_process_message.adoc#_business_message_state[Business Message State diagram]

== DB Data Model Requirements

This requirements ONLY reflect our requirements agains the database. They are resulting from other requirements.

=== D1.1: As ProcessPersistenceService I need to access at any time by ID my transported message / message process entity so I can process it.


=== D1.2: As ProcessPersistenceService I need to make sure that a process step can only be executed once!

This is very important, because the notication system (JMS) is not part of the transaction so there is no guarantee that a notification will not be recevied twice or at all.

=== D1.3: As ProcessPersistenceService I need to provide a list which messages have not been updated for a specific time so a timer job can identify stuck messages.

This is very important, because the notication system (JMS) is not part of the transaction so there is no guarantee that a notification will not be recevied twice or at all.

I also need to know a estimation how long the message will stay in current state. E.g.: Sending state? => retry would not usefull.
Other similary states in future?
Maybe better to offload this into state model table!


NOTE: The recover timer job will need definitiv some additional information if a MessageProcess is stuck or not. Maybe the ProcessStep needs some kind of result and only if the result is null it should be retried?


=== D2: As MessagePersistenceService I need to know very fast which business message has not already been rejected or confirmed so I can check which evidence is missing for this specific business message.

This is needed to run/trigger evidence timeouts.

=== D3: As MessagePersistenceService I need to find very fast a related business message. So I can link a ConfirmationMessage to the according BusinessMessage.

The refToMessage can either use the ebmsId (for incoming international confirmation messages) or the backendMessageId (for by the backend generated confirmation message/s (triggers))

=== D3.1: As MessagePersistenceService I also have to provide all evidences to a specific business message, so an additional evidence can be created.

This is required to generate the RELAY_REMMD_EVIDENCE or DELVIERY_EVIDENCE out of the evidence trigger.


=== D4: As TransportService I need to mark a message as ready to transport. 
//=== D3: As LargeFilePersistenceServiceDBImpl I need to store large files into DB.
//
//This requirement only covers the need to store large files into the DB. The LargeFilePersistenceServiceDBImpl is another LargeFileService implementation similar to LargeFileFSImpl (Storage on Filesystem). So it is decoupled from other DB Tables.


[plantuml]
----
@startuml

package processing <<rectangle>> {

class DC5_Process
{
  id: Int
  connectorMessageId: String/UUID
  created: Timestamp
  finished: Timestamp
}

note "Splitting up into the Process and Process steps will enforce\n \
that a process step can only be executed once\n \
(A retry logic could add a attempt counter to DC5_ProcessStep)" as N1

class DC5_ProcessStep {
  stepKey : String
  created: Timestamp
  msg: String/JSON
}

DC5_Process "1" -- "*" DC5_ProcessStep : has steps

N1 .. DC5_ProcessStep
N1 .. DC5_Process

}


package ecodex <<rectangle>> {

class BusinessMessage {
  id: Int
  connectorMessageId: String/UUID
  isRejectedOrConfirmed: Boolean
  ebmsMessageId: String
  backendMessageId: String
}

class Evidence {
  id: Int
  type: String
  evidenceXml: String
}

BusinessMessage "1" *-- "*" Evidence : has steps

note "D3 adds ebmsMessageId and backendMessageId to find related message" as N2
N2 .. BusinessMessage

note "D3.1 adds this additional table" as N3
N3 .. Evidence

}





@enduml
----

